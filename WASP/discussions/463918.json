[
  {
    "Id": "1113135",
    "ThreadId": "463918",
    "Html": "I am having challenges with WASP send-click. The demo script below shows the challenges. Firefox will accept the click on the File menu, but not the click on the main web page display. IE &amp; Chrome ignore the clicks. Notepad ignores the click on the File menu, but does correctly click on the main edit area, select all text and copy it to the window clipboard. Any and all suggestions would  be appreciated.<br />\n<pre><code># Initialization\nImport-Module c:\\wasp\\wasp.dll\nAdd-Type -Assembly System.Windows.Forms \nclear-host\n$str = &quot;the quick brown fox`njumped over the lazy dog`n&quot;\n\n# Set up apps to test.\n$app_list = $MyInvocation.UnboundArguments\nif (!$app_list) {\n   $app_list = &quot;firefox&quot;, &quot;iexplore&quot;, &quot;chrome&quot;, &quot;notepad&quot;\n}\n\n# Main loop\nforeach ($app in $app_list) {\n\n   # Set coordinates to click on for the app.\n   switch ($app) {\n      chrome {\n         $x1 = 20 # Apps button location\n         $y1 = 80\n         $x2 = 100 # main web page display\n         $y2 = 150\n      }\n      iexplore {\n         $x1 = 20 # File menu location\n         $y1 = 80\n         $x2 = 100\n         $y2 = 200\n      }\n      firefox {\n         $x1 = 20 # File menu location\n         $y1 = 35\n         $x2 = 100 # main web page display\n         $y2 = 150\n      }\n      notepad {\n         $x1 = 20 # File menu\n         $y1 = 35\n         $x2 = 40 # 3rd line of main editing window\n         $y2 = 100\n         # send-keys -window $h -keys &quot;$str $str $str $str&quot;\n      }\n\n      default {\n         &quot;ERROR: unknown app=$app&quot;\n         continue\n      }\n   }\n   &quot;app=$app x1=$x1 y1=$y1 x2=$x2 y2=$y2&quot;\n\n   # Start the application, get the window object, save object parms.\n   start-process -filepath &quot;$app&quot;\n   start-sleep -s 5\n   if ($app -eq &quot;iexplore&quot;) {\n      $w = select-window -title *explorer*\n   } else {\n      $w = select-window -title *$app*\n   }\n   $w = $w | select-object -first 1\n   $h = $w.handle\n   $p = $w.processid\n   $t = $w.title\n   &quot;app=$app h=$h p=$p t=$t&quot;\n\n   # If no window handle found, complain and move on.\n   if (!$h) {\n      &quot;ERROR: app=$app got null handle&quot;\n      continue\n   }\n\n   # Get window position and mouse offsets.\n   $pos=Get-WindowPosition $h\n   $l = $pos.Location\n   $x_off = $l.X\n   $y_off = $l.Y\n   &quot;pos=$pos offset x=$x_off y=$y_off&quot;\n\n   # Move mouse, then click on first location.\n   [System.Windows.Forms.Cursor]::Position = New-Object System.Drawing.Point(($x_off + $x1), ($y_off +$y1))\n   start-sleep -s 1\n   send-click -left $x1 -top $y1 -window $h -button left\n\n   # Wait, then close first menu\n   start-sleep -s 3\n   send-keys -window $h -keys &quot;{Esc}&quot;\n\n   # Add text for notepad window\n   if ($app -eq &quot;notepad&quot;) {\n      send-keys -window $h -keys &quot;${str}${str}${str}${str}${str}${str}${str}${str}&quot;\n   }\n\n   # Move mouse, then click on second location.\n   start-sleep -s 1\n   [System.Windows.Forms.Cursor]::Position = New-Object System.Drawing.Point(($x_off + $x2), ($y_off +$y2))\n   send-click -window $h -left $x2 -top $y2 -button left\n\n   # Try to select all text &amp; copy it.\n   start-sleep -s 1\n   send-keys -window $h -keys &quot;^a&quot;\n   start-sleep -s 1\n   send-keys -window $h -keys &quot;^c&quot;\n\n   # Get rid of app &amp; window.\n   &quot;stopping $app&quot;\n   start-sleep -s 1\n   stop-process -id $p -force\n   start-sleep -s 5 # wait for stop to take effect\n}\n</code></pre>\n\n",
    "PostedDate": "2013-10-28T08:42:35.077-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1113371",
    "ThreadId": "463918",
    "Html": "Short version (let me know if you need more, but I'm on my way out of the office):\r<br />\n<br />\nYou should try not to automate base on mouse clicks unless you can't avoid it -- mouse clicks automation is the most fragile: it breaks when resolution changes, or font-sizes change, and whenever things are moved on a UI even by just a few pixels.  Use keystrokes (Alt+* hotkeys) for menus and buttons whenever possible.  This is something that the new module is much better about, since it gives you Invoke-* cmdlets for stuff like buttons and menus...\r<br />\n<br />\nAdditionally, you shouldn't really drive browser automation with generic automation tools -- you need something that gets into the page and lets you automate based on the rendered DOM. My choice for browser automation is Selenium.  I've done <em>some</em> work with Selenium in PowerShell using the WebDriver apis (I wrote a blog post and posted something to PoshCode, I think) and there's a project here on CodePlex (SePx? SePs? something like that) which claims to be a full port for PowerShell (I haven't tried that).<br />\n",
    "PostedDate": "2013-10-28T13:28:15.727-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1114114",
    "ThreadId": "463918",
    "Html": "Thanks for the info on upcoming WASP2. I fully agree that using X,Y mouse coordinates is a very fragile automation approach, but sometimes its the only way.  I had that experience several years back using the Network Automation tool set. I am trying to understand what I can and cant do with WASP. I will make use of hot keys as much as possible, and will check out the other tools you mentioned. Thanks again!<br />\n",
    "PostedDate": "2013-10-30T05:58:17.54-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]